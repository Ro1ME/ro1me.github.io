<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2025/03/20/%E7%A8%8B%E5%BA%8F%E6%8F%92%E6%A1%A9/"/>
      <url>/2025/03/20/%E7%A8%8B%E5%BA%8F%E6%8F%92%E6%A1%A9/</url>
      
        <content type="html"><![CDATA[<hr><p>title： 程序插桩<br>categories：</p><ul><li>Fuzz</li><li>AFL<br>tags：</li><li>模糊测试</li><li>安全工具</li></ul><hr><h2 id="程序插桩"><a href="#程序插桩" class="headerlink" title="程序插桩"></a>程序插桩</h2><p>定义：往被测试程序中插入测试代码以达到测试目的的方法，插入的测试代码被称为探针。</p><p>方法：（测试代码插入的时间）</p><ol><li>目标代码插桩</li><li>源代码插桩</li></ol><h3 id="目标代码插桩（动态程序分析方法）"><a href="#目标代码插桩（动态程序分析方法）" class="headerlink" title="目标代码插桩（动态程序分析方法）"></a>目标代码插桩（动态程序分析方法）</h3><p>特点：不需要代码重新编译或者链接程序，并且目标代码的格式和具体的编程语言无关，主要和操作系统相关。</p><p>原理：直接修改二进制程序（无需源码），在程序运行平台和底层操作系统之间建立中间层，通过动态中间层（如Pin、DynamoRIO）插入探针代码，监控内存、指令执行等</p><h4 id="工具示例"><a href="#工具示例" class="headerlink" title="工具示例"></a>工具示例</h4><ul><li>Pin（Intel开发）：用于动态二进制分析，支持指令跟踪、缓存模拟等，常用于大型软件（如Office）测试。</li><li>DynamoRIO：支持实时代码转换，适用于内存调试和性能分析。</li></ul><h3 id="源代码插桩"><a href="#源代码插桩" class="headerlink" title="源代码插桩"></a>源代码插桩</h3><p>原理：在源代码编译前，通过词法、语法分析确定插桩位置，<strong>直接插入探针代码</strong>。例如在条件分支、循环或函数入口&#x2F;出口处插入日志或断言。</p><p>示例：C代码在第13行插入宏<code>ASSERT(y)</code>，用于检测除数是否为0：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(y) <span class="keyword">if</span>(y)&#123; printf(<span class="string">&quot;出错文件：%s\n&quot;</span>, __FILE__); \</span></span><br><span class="line"><span class="meta">                        printf(<span class="string">&quot;在第%d行：\n&quot;</span>, __LINE__); \</span></span><br><span class="line"><span class="meta">                        printf(<span class="string">&quot;提示：除数不能为0！\n&quot;</span>); &#125;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    ASSERT(y == <span class="number">0</span>);  <span class="comment">// 插桩点：检测除数合法性</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x / y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>y=0</code>时，插桩代码会触发错误提示.</p><h3 id="开源插桩工具"><a href="#开源插桩工具" class="headerlink" title="开源插桩工具"></a><strong>开源插桩工具</strong></h3><h4 id="动态二进制插桩"><a href="#动态二进制插桩" class="headerlink" title="动态二进制插桩"></a><strong>动态二进制插桩</strong></h4><ul><li><p><strong>Intel Pin</strong></p><ul><li><p><strong>特点</strong>：无需修改源码，通过运行时注入代码追踪程序执行路径，支持x86&#x2F;ARM&#x2F;MIPS等多架构。</p></li><li><p><strong>应用</strong>：性能分析（指令计数）、内存访问监控、安全漏洞检测。</p></li><li><p>示例命令：用于统计指令数或检测缓冲区溢出</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pin -t &lt;工具.so&gt; -- &lt;目标程序&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>项目地址</strong>：<a href="https://www.wenxiaobai.com/chat/200006#">Intel Pin</a></p></li></ul></li><li><p><strong>Frida</strong></p><ul><li><p><strong>特点</strong>：跨平台动态插桩框架，支持Android&#x2F;iOS&#x2F;Windows，通过JavaScript脚本注入实现Hook。</p></li><li><p><strong>应用</strong>：移动端逆向工程（如Hook ART核心函数）、实时监控方法调用。</p></li><li><p>示例代码</p><p>：Hook Android的 <code>libart.so</code>函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JavaScriptInterceptor</span>.<span class="title function_">attach</span>(<span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;libart.so&quot;</span>, <span class="string">&quot;art_method_invoke&quot;</span>), &#123;</span><br><span class="line">  <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Method called: &quot;</span> + args[<span class="number">0</span>]); &#125;</span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure></li><li><p><strong>项目地址</strong>：<a href="https://www.wenxiaobai.com/chat/200006#">Frida</a></p></li></ul></li><li><p><strong>TinyInst</strong></p><ul><li><strong>特点</strong>：轻量级动态插桩库，仅对选定模块插桩，减少性能损耗，支持Windows&#x2F;Linux&#x2F;macOS。</li><li><strong>应用</strong>：模糊测试（如AFL++的覆盖率追踪）、模块级代码监控。</li><li><strong>项目地址</strong>：<a href="https://www.wenxiaobai.com/chat/200006#">TinyInst</a></li></ul></li></ul><h4 id="静态源代码插桩"><a href="#静态源代码插桩" class="headerlink" title="静态源代码插桩"></a><strong>静态源代码插桩</strong></h4><ul><li><p><strong>JaCoCo（Java Code Coverage）</strong></p><ul><li><p><strong>特点</strong>：基于字节码插桩，生成代码覆盖率报告，支持行、分支、方法级覆盖率统计。</p></li><li><p><strong>应用</strong>：单元测试覆盖率分析，集成到Maven&#x2F;Gradle构建流程。</p></li><li><p>配置示例：在<code>pom.xml</code>中添加插件：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jacoco<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jacoco-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>项目地址</strong>：<a href="https://www.wenxiaobai.com/chat/200006#">JaCoCo</a></p></li></ul></li><li><p><strong>OpenTelemetry</strong></p><ul><li><p><strong>特点</strong>：跨语言遥测框架（支持Java&#x2F;Python&#x2F;Go），提供标准化指标、日志、跟踪数据收集。</p></li><li><p><strong>应用</strong>：分布式系统性能监控，与Prometheus&#x2F;Grafana集成。</p></li><li><p>示例：在Python中插桩HTTP请求耗时</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> opentelemetry <span class="keyword">import</span> trace</span><br><span class="line">tracer = trace.get_tracer(__name__)</span><br><span class="line"><span class="keyword">with</span> tracer.start_as_current_span(<span class="string">&quot;http_request&quot;</span>):</span><br><span class="line">    requests.get(<span class="string">&quot;https://example.com&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>项目地址</strong>：<a href="https://www.wenxiaobai.com/chat/200006#">OpenTelemetry</a></p></li></ul></li></ul><h4 id="编译器级插桩"><a href="#编译器级插桩" class="headerlink" title="编译器级插桩"></a><strong>编译器级插桩</strong></h4><ul><li><p><strong>LLVM Sanitizer</strong></p><ul><li><p><strong>特点</strong>：基于LLVM中间表示的插桩，支持ASAN（内存检测）、UBSan（未定义行为检测）。</p></li><li><p><strong>应用</strong>：C&#x2F;C++程序内存错误检测（如堆溢出、释放后使用）。</p></li><li><p><strong>编译选项：</strong><code>clang -fsanitize=address -g program.c</code></p></li></ul></li><li><p><strong>AFL（American Fuzzy Lop）</strong></p><ul><li><strong>特点</strong>：覆盖率引导的模糊测试工具，通过插桩追踪边覆盖率优化测试用例生成。</li><li><strong>应用</strong>：漏洞挖掘（如触发程序崩溃路径）。</li><li>**插桩原理：**在编译时注入覆盖率统计代码，共享内存记录执行路径</li><li><strong>项目地址</strong>：<a href="https://www.wenxiaobai.com/chat/200006#">AFL</a></li></ul></li></ul><h3 id="如何选择插桩方法"><a href="#如何选择插桩方法" class="headerlink" title="如何选择插桩方法"></a>如何选择插桩方法</h3><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐方法</strong></th><th><strong>工具示例</strong></th></tr></thead><tbody><tr><td>需高精度测试（有源码）</td><td>源代码插桩</td><td>GCC插桩、ASSERT宏</td></tr><tr><td>闭源程序分析</td><td>目标代码插桩</td><td>Pin、DynamoRIO</td></tr><tr><td>实时性能监控</td><td>动态二进制插桩</td><td>Frida、DynamoRIO</td></tr><tr><td>大规模覆盖率统计</td><td>自动化插桩工具</td><td>OpenTelemetry</td></tr></tbody></table><p>通过上述分类与示例可见，程序插桩是连接静态分析与动态执行的关键技术，广泛应用于软件工程的全生命周期。实际应用中需权衡精度、效率与侵入性，结合具体场景选择工具和策略。</p><h3 id="如何使用插桩工具"><a href="#如何使用插桩工具" class="headerlink" title="如何使用插桩工具"></a>如何使用插桩工具</h3><h4 id="第1步：选择工具"><a href="#第1步：选择工具" class="headerlink" title="第1步：选择工具"></a>第1步：选择工具</h4><p>常用工具及适用场景：</p><table><thead><tr><th>工具</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>Intel Pin</strong></td><td>支持Windows&#x2F;Linux，适合指令级监控（如统计指令执行次数）</td><td>性能分析、漏洞挖掘</td></tr><tr><td><strong>DynamoRIO</strong></td><td>支持内存调试、代码覆盖率统计，模块化接口更灵活</td><td>逆向工程、安全检测</td></tr><tr><td><strong>Frida</strong></td><td>支持移动端（Android&#x2F;iOS），通过JavaScript脚本快速插桩</td><td>App逆向、动态调试</td></tr></tbody></table><h4 id="第2步：编写探针逻辑（以Intel-Pin为例）"><a href="#第2步：编写探针逻辑（以Intel-Pin为例）" class="headerlink" title="第2步：编写探针逻辑（以Intel Pin为例）"></a>第2步：编写探针逻辑（以Intel Pin为例）</h4><p>假设我们要统计程序中所有加法指令的执行次数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pin.H&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局计数器</span></span><br><span class="line">UINT64 addCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入探针代码的函数</span></span><br><span class="line"><span class="function">VOID <span class="title">CountAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    addCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测指令是否为加法指令</span></span><br><span class="line"><span class="function">VOID <span class="title">Instruction</span><span class="params">(INS ins, VOID *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">INS_IsAdd</span>(ins)) &#123; <span class="comment">// 如果是加法指令</span></span><br><span class="line">        <span class="comment">// 在指令执行前插入探针函数</span></span><br><span class="line">        <span class="built_in">INS_InsertCall</span>(ins, IPOINT_BEFORE, (AFUNPTR)CountAdd, IARG_END);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">PIN_Init</span>(argc, argv);</span><br><span class="line">    <span class="built_in">INS_AddInstrumentFunction</span>(Instruction, <span class="number">0</span>); <span class="comment">// 注册指令级插桩函数</span></span><br><span class="line">    <span class="built_in">PIN_StartProgram</span>(); <span class="comment">// 启动目标程序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的作用是：每当程序执行加法指令时，计数器<code>addCount</code>加1 。</p><h4 id="第3步：编译与运行"><a href="#第3步：编译与运行" class="headerlink" title="第3步：编译与运行"></a>第3步：编译与运行</h4><ol><li><p>编译Pintool（Pin的插桩工具）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入Pin的示例目录</span></span><br><span class="line"><span class="built_in">cd</span> pin-3.11/source/tools/ManualExamples</span><br><span class="line"><span class="comment"># 编译（以64位Linux为例）</span></span><br><span class="line">make obj-intel64/add_counter.so TARGET=intel64</span><br></pre></td></tr></table></figure></li><li><p>运行目标程序并插桩：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设目标程序是test.exe</span></span><br><span class="line">../../../pin -t obj-intel64/add_counter.so -- ./test.exe</span><br></pre></td></tr></table></figure></li><li><p>查看结果：程序运行结束后，会在终端输出加法指令的总执行次数。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/03/19/afl/"/>
      <url>/2025/03/19/afl/</url>
      
        <content type="html"><![CDATA[<hr><p>title： 以AFL切入Fuzz的基础知识学习<br>categories：</p><ul><li>Fuzz</li><li>AFL<br>tags：</li><li>模糊测试</li><li>安全工具</li></ul><hr><h2 id="程序插桩"><a href="#程序插桩" class="headerlink" title="程序插桩"></a>程序插桩</h2><p>定义：往被测试程序中插入测试代码以达到测试目的的方法，插入的测试代码被称为探针。</p><p>方法：（测试代码插入的时间）</p><ol><li>目标代码插桩</li><li>源代码插桩</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MYFirst</span> &#123;</span><br><span class="line"><span class="comment">/* 第一个Java程序</span></span><br><span class="line"><span class="comment"> * 打印Hello World</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;Hello World&quot;</span>);<span class="comment">// 打印Hello world</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="目标代码插桩（动态程序分析方法）"><a href="#目标代码插桩（动态程序分析方法）" class="headerlink" title="目标代码插桩（动态程序分析方法）"></a>目标代码插桩（动态程序分析方法）</h3><p>定义：向目标代码（二进制）插入测试代码。</p><p>功能：监控程序运行时的内存监控、指令追踪、错误检测等。</p><p>特点：不需要代码重新编译或者链接程序，并且目标代码的格式和具体的编程语言无关，主要和操作系统相关。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在程序运行平台和底层操作系统之间建立中间层</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/03/18/hello-world/"/>
      <url>/2025/03/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
